<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/elo320.css">
    <link rel="stylesheet" href="css/animRestricciones.css">
    <link rel="stylesheet" href="path/to/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">

    <style>
        .fragment.bold {
            font-weight: normal;
        }

        .fragment.bold.visible {
            font-weight: bold;
        }

        .reveal td {
            font-size: 60%;
        }

        .tg {
            border-collapse: collapse;
            border-spacing: 0
        }

        .tg td {
            border-color: black;
            border-style: solid;
            border-width: 1px;
            font-family: Arial, sans-serif;
            font-size: 28px;
            overflow: hidden;
            padding: 10px 5px;
            word-break: normal;
        }

        .tg th {
            border-color: black;
            border-style: solid;
            border-width: 1px;
            font-family: Arial, sans-serif;
            font-size: 28px;
            font-weight: normal;
            overflow: hidden;
            padding: 10px 5px;
            word-break: normal;
        }

        .tg .tg-0lax {
            text-align: center;
            vertical-align: center;
            font-size: 3vw;
            border-width: 2px
        }

        .tg .tg-small {
            text-align: center;
            vertical-align: center;
            font-size: 2vw
        }

        .smalltab {
            font-size: 2vw
        }
    </style>
</head>

<body>

    <div class="reveal">
        <div class="slides">

            <!-- Title Slide -->
            <section class="Title" data-include>
                <p class="r-fit-text">ELO320 - Estructuras de Datos y Algoritmos</p>
                <h2>Punteros</h2>
                <p>Marie González-Inostroza</p>

            </section>




            <!--  <section>
                <h4>Enumeración</h4>
                <div class="fragment">
                    <pre><code class="language-c" data-trim>
enum color {
    rojo, 
    amarillo, 
    verde=20, 
    azul};

int col = rojo;

if (col != azul){ 
    printf("No es azul\n");}
        </code></pre>
                </div>
                <div class="fragment">
                    <p><b>Python (clases)</b></p>
                    <pre><code class="language-python" data-trim>
class Colors(Enum):
    red = 1
    yellow = 2
    green = 3
        </code></pre>
                </div>
            </section> -->

            <section>
                <h2>Programa en Memoria</h2>
                <ul>
                    <li><em>Ejecutar</em>: llevar un programa (binario) a memoria.</li>
                    <li><em>Variables y Constantes</em>: espacios que se asignan y liberan en memoria</li>
                    <li><em>Ciclo de vida</em>: cuándo se crea y destruye una variable</li>
                    <li><em>Ámbito</em>: qué código tiene acceso a la variable</li>
                </ul>
                <img src="images/compila.png" alt="Compilación" style="width:80%;">
            </section>

            <section>
                <h2>Taxonomía de la memoria</h2>
                <p>Segmentos de memoria:</p>
                <img src="images/memoriastack.png" alt="Memoria stack" style="width:70%;">
            </section>

            <section>
                <h2>Taxonomía de la memoria</h2>
                <ol>
                    <li><b>Memoria text o de código</b></li>
                    <li><b>Memoria static o estática</b></li>
                    <li><b>Memoria heap</b></li>
                    <li><b>Memoria stack o call stack</b></li>
                </ol>
            </section>

            <section>
                <h2>Memoria text</h2>
                <p style="font-size:1.5em;">Donde el programa compilado se mantiene en memoria.</p>
            </section>

            <section>
                <h2>Memoria static</h2>
                <p>Mantiene variables globales y estáticas.</p>
                <p>Ligado estático: variables (y valores) en la memoria hasta que programa termina.</p>
            </section>

            <section>
                <h2>Memoria heap</h2>
                <p>Permite al programador crear y eliminar objetos de memoria dinámicamente.</p>
                <p>Son referenciadas indirectamente mediante <b>punteros</b> y/o <b>referencias</b>.</p>
            </section>

            <section>
                <h2>Memoria stack</h2>
                <p>Área dinámica de memoria donde se guardan las variables locales y la información de las funciones.
                </p>
                <p>Objetos se asignan/liberan automáticamente en tiempo de ejecución.</p>
                <p>Manejado <b>automáticamente</b> por el compilador.</p>
            </section>

            <!-- Ejemplo de código -->
            <section>
                <h2>Variables estáticas - static</h2>
                <pre><code class="language-c" data-trim>
long int y; // var global

static int z = 1; // global estatica;
// solo visible a este archivo.

int est3_st4tic(){
  static int a=0; // local estatica
  a++; // no pierde su valor al finalizar ámbito
  return a;
}
                  
int fun() {
  int i;
  for(i=0;i<10;i++){
    printf("vuelta numero %d\n", i);
    printf("pero no pierde su valor: %d\n", est3_st4tic());
  }
  return 0;
}
        </code></pre>
            </section>

            <!-- Ejemplo de memoria -->
            <section>
                <h2>Ejemplo</h2>
                <img src="images/progmemoria.png" alt="Memoria programa" style="width:90%;">
            </section>

            <!-- Dirección de memoria -->
            <section>
                <h2>Dirección de Memoria o Referencia</h2>
                <ul>
                    <li>Las variables de stack son cajones que pueden guardar valores.</li>
                </ul>
                <pre><code class="language-c" data-trim>
#include<stdio.h>
int main(){
  int b;
  scanf("%d", &b); // ¿Por qué &b?
  return 0;
}
        </code></pre>
                <p>El operador & nos entrega la ubicación de memoria donde se encuentra el cajón.</p>
            </section>

            <!-- Analogía biblioteca -->
            <section>
                <h2>Analogía - Biblioteca</h2>
                <img src="images/label.png" style="width:70%;">
                <ul>
                    <li>Valor 320 como identificador del libro.</li>
                    <li><code>pu</code> → casillero.</li>
                    <li><code>&pu</code> → ubicación casillero → pasillo 3, estante 2, fila 4.</li>
                </ul>
            </section>

            <!-- Punteros -->
            <section>
                <h2>Punteros en C</h2>
                <pre><code class="language-c" data-trim>
int utfsm1 = 1680;
int utfsm2 = 3939; 

int *dir = NULL; // puntero a int
dir = &utfsm1;

printf("Dirección dentro de dir: %p\n", dir);
printf("Valor dir: %d\n", *dir);
printf("Dirección de dir: %p\n", &dir);
        </code></pre>
            </section>

        </div>
    </div>

  
  
      <!-- Aritmética de punteros -->
      <section>
        <h2>Aritmética de Punteros</h2>
        <ul>
          <li>Indicar el tipo a un puntero sirve para realizar aritmética de punteros.</li>
          <li>Transforma 1 unidad decimal en 1 unidad según el tamaño del tipo.</li>
          <li>Podemos saber cuánta memoria hay entre un puntero y el siguiente (si existe).</li>
          <li>Ejemplo: puntero a int avanza de a 4 bytes.</li>
        </ul>
        <pre><code class="language-c">
float num = 2.5;
float *f;
f = &num; //Dirección a num.

printf("Direccion f: %p\n", f); //¿Cuál es la diferencia
printf("Direccion f+1: %p\n", f+1); //entre f y f+1?
        </code></pre>
        <p>Respuesta: La diferencia es de 4 bytes (tamaño de float).</p>
      </section>

      <!-- Arreglos y punteros -->
      <section>
        <h2>Arreglos y Aritmética de Punteros</h2>
        <ul>
          <li>En C un arreglo puede trabajarse con aritmética de punteros.</li>
          <li>Los arreglos son compatibles con punteros.</li>
          <li>El compilador hace coerción y esto permite la aritmética de punteros.</li>
        </ul>
        <pre><code class="language-c">
int a[10], i;
int *pa, *pb;
pa = &a[0]; /* dir. elemento 0 de arreglo a */
pa = a;     /* lo mismo con coerción */
pb = &a;    /* dir. de arreglo a. tamaño 10 int */

for (i=0; i<10; i++){
    printf("%d ", a[i]);
    printf("%d ", *(pa+i));
    printf("%d ", *(a+i));
}

printf("%d ", *(pb+1)); //¿Qué pasa acá?
        </code></pre>
      </section>

      <!-- Paso por valor -->
      <section>
        <h2>Funciones y Punteros: Paso por Valor</h2>
        <ul>
          <li>Los parámetros copian los valores que fueron pasados como parámetros.</li>
          <li>Las variables originales se mantienen inalteradas.</li>
        </ul>
        <pre><code class="language-c">
#include<stdio.h>

void swap(int a, int b){
    int temp;
    temp = a;
    a = b;
    b = temp;
}

int main(){
    int x=2, y=3;
    swap(x,y);
    printf("x: %d, y: %d\n", x, y); //¿Qué imprime?
    return 0;
}
        </code></pre>
      </section>

      <!-- Paso por referencia -->
      <section>
        <h2>Funciones y Punteros: Paso por Referencia</h2>
        <ul>
          <li>Los parámetros son punteros locales, pero la desreferencia apunta a la misma variable.</li>
          <li>Las variables originales se modifican.</li>
        </ul>
        <pre><code class="language-c">
#include<stdio.h>

void swap(int *a, int *b){
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

int main(){
    int x=2, y=3;
    swap(&x,&y);
    printf("x: %d, y: %d\n", x, y); //¿Qué imprime?
    return 0;
}
        </code></pre>
      </section>

      <section>
        <h2>Funciones y Punteros: Paso por Referencia (Caso 3)</h2>
        <ul>
          <li>¿Funciona este tercer caso?</li>
        </ul>
        <pre><code class="language-c">
#include<stdio.h>

void swap(int *a, int *b){
    int *temp;
    temp = a;
    a = b;
    b = temp;
}

int main(){
    int x=2, y=3;
    swap(&x,&y);
    printf("x: %d, y: %d\n", x, y); //¿Qué imprime?
    return 0;
}
        </code></pre>
        <p>Respuesta: No, no funciona. Punteros locales.</p>
      </section>

      <section>
        <h2>Funciones y Punteros: Paso por Referencia (Caso 4)</h2>
        <ul>
          <li>¿Funciona este cuarto caso?</li>
        </ul>
        <pre><code class="language-c">
#include<stdio.h>

void swap(int *a, int *b){
    int *temp;
    temp = a;
    *a = *b;
    *b = *temp;
}

int main(){
    int x=2, y=3;
    swap(&x,&y);
    printf("x: %d, y: %d\n", x, y); //¿Qué imprime?
    return 0;
}
        </code></pre>
        <p>Respuesta: No, se pierde el valor de *a.</p>
      </section>



    <section>
        <h4>Actividad 4.2: Strings y Structs en C</h4>
        <p>Completa las funciones para buscar en un arreglo de Structs.</p>
        <p>

            El código base está en Classroom. Completa las funciones vacías y realiza pruebas con distintos
            valores.
            <a href="https://classroom.github.com/a/OQ7AZUuO" target="_blank">
                https://classroom.github.com/a/OQ7AZUuO
        </p>
    </section>

    </div>

    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/countdown/countdown.js"></script>
    <script src="plugin/animate/plugin.js"></script>
    <script src="plugin/animate/svg.min.js"></script>
    <script src="plugin/math/math.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            slideNumber: true,
            autoAnimateEasing: 'ease-out',
            autoAnimateDuration: 0.8,
            hash: true,
            slideNumber: true,
            dependencies: [

                { src: "plugin/countdown/countdown.js" },

            ],
            animate: {
                autoplay: true
            },

            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [RevealMath.KaTeX, RevealMarkdown, RevealHighlight, RevealNotes, RevealAnimate],
            countdown: { defaultTime: 300, autostart: true },


            autoAnimateUnmatched: true

        });

        Reveal.configure({ pdfSeparateFragments: false });
    </script>
</body>

</html>